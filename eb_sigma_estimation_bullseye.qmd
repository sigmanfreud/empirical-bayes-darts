---
title: "eb_sigma_estimation_bullseye"
format: html
editor: visual
---

# Estimating variance of throws at Bullseye

## Preliminaries

```{r}
# Define the dartboard parameters (in mm)
bullseye_inner_radius <- 12.7
bullseye_outer_radius <- 31.8
triple_ring_inner_radius <- 99
triple_ring_outer_radius <- 107
double_ring_inner_radius <- 162
double_ring_outer_radius <- 170
```

Returns the region of a given point.

```{r}
get_dartboard_region_vectorized <- function(x, y) {
  # Constants
  segment_numbers <- c(20, 1, 18, 4, 13, 6, 10, 15, 2, 17,
                       3, 19, 7, 16, 8, 11, 14, 9, 12, 5)
  segment_width <- 360 / 20

  bull_inner <- 6.35
  bull_outer <- 15.9
  triple_inner <- 99
  triple_outer <- 107
  double_inner <- 162
  double_outer <- 170

  r <- sqrt(x^2 + y^2)
  theta <- (90 - atan2(y, x) * 180 / pi) %% 360
  segment_idx <- floor(theta / segment_width) + 1
  segment <- segment_numbers[segment_idx]

  region <- character(length(x))

  region[r <= bull_inner] <- "Bull"
  region[r > bull_inner & r <= bull_outer] <- "Outer Bull"
  region[r > bull_outer & r <= triple_inner] <- paste0("Single (Inner) ", segment[r > bull_outer & r <= triple_inner])
  region[r > triple_inner & r <= triple_outer] <- paste0("T", segment[r > triple_inner & r <= triple_outer])
  region[r > triple_outer & r <= double_inner] <- paste0("Single (Outer) ", segment[r > triple_outer & r <= double_inner])
  region[r > double_inner & r <= double_outer] <- paste0("D", segment[r > double_inner & r <= double_outer])
  region[r > double_outer] <- "Miss"

  return(region)
}
```

Check what region a point is inside.

```{r}
is_inside_region_vectorized <- function(x, y, target_region) {
  regions <- get_dartboard_region_vectorized(x, y)
  return(regions == target_region)
}

```

## Data Generation

Do this part later.

## Prior Generation

```{r}
library(MASS)
library(mvtnorm)
library(stats4)

# Bullseye annuli radii (explicit computation possible)
bull_radii <- c(0, 6.35, 15.9, 99, 107, 162, 170)

# Function to compute exact probability for bullseye annuli
dart_annulus_probability <- function(r1, r2, sigma2) {
  pchisq(r2^2 / sigma2, df = 2) - pchisq(r1^2 / sigma2, df = 2)
}

# Log-likelihood function for Bullseye using exact annulus probabilities
log_likelihood_bull_ab <- function(a, b, observed_counts, radii = bull_radii, n_theta_samples = 5000) {
  if (a <= 0 || b <= 0) return(-Inf)

  # Sample theta from inverse-chi-squared(a, b)
  theta_samples <- b / rchisq(n_theta_samples, df = a)
  logL_total <- 0

  for (i in seq_along(observed_counts)) {
    n_obs <- observed_counts[i]
    if (n_obs == 0) next

    probs <- dart_annulus_probability(radii[i], radii[i+1], theta_samples)
    avg_prob <- mean(probs)
    avg_prob <- max(avg_prob, 1e-12)

    logL_total <- logL_total + n_obs * log(avg_prob)
  }
  return(logL_total)
}

# Wrapper for stats4::mle for Bullseye
mle_bull_ab <- function(observed_counts, radii = bull_radii) {
  neg_log_likelihood <- function(a, b) {
    -log_likelihood_bull_ab(a, b, observed_counts, radii)
  }

  mle_result <- mle(neg_log_likelihood, start = list(a = 5, b = 1000), method = "L-BFGS-B", lower = c(0.1, 0.1))
  return(mle_result)
}

# Example usage for Bullseye data:
set.seed(123)
observed_counts_bull <- c(14, 48, 3, 0, 0, 0)  # Example observed annulus counts

mle_result_bull <- mle_bull_ab(observed_counts_bull)
summary(mle_result_bull)
```

Now, we generate some plots.

```{r}
# Extract MLE estimates of a and b
mle_a <- coef(mle_result_bull)[["a"]]
mle_b <- coef(mle_result_bull)[["b"]]

# Define Inverse Chi-Squared density
dinvchisq <- function(theta, a, b) {
  const <- (b/2)^(a/2) / gamma(a/2)
  const * theta^(-(a/2 + 1)) * exp(-b / (2 * theta))
}

# Create a range of theta values for plotting
theta_vals <- seq(0.1, 1000, length.out = 500)
density_vals <- dinvchisq(theta_vals, mle_a, mle_b)

# Plot the prior density
plot(theta_vals, density_vals, type = "l", lwd = 2, col = "blue",
     main = "Estimated Prior Distribution (Inverse Chi-Squared)",
     xlab = expression(theta), ylab = "Density")
```

## Likelihood Generation

In this case, the problem is quite tractable.

```{r}
log_likelihood <- function(sigma, counts, radii, tol = 1e-12) {
  if (sigma <= 0) return(-Inf)
  
  scaled_radii_sq <- (radii^2) / sigma
  F_values <- pchisq(scaled_radii_sq, df = 2)
  probs <- diff(F_values)
  
  # Apply tolerance: replace very small probabilities with a tiny value
  probs[probs < tol] <- tol
  
  logL <- sum(counts * log(probs))
  return(logL)
}
```

Now, we test an example.

```{r}
radii <- c(0,         # r_{D_0} = 0
           6.35,      # Bullseye (inner bull)
           15.9,      # Outer bull
           99,        # Triple ring inner
           107,       # Triple ring outer
           162,       # Double ring inner
           170)       # Double ring outer (r_{D_R})

counts <- c(8,4,30,20,4,0)  # Example: counts for each annulus
sigma_guess <- 1                       # Initial guess for sigma

log_likelihood(sigma_guess, counts, radii)
```

```{r}
library(ggplot2)


sigma_vals <- seq(1, 5000, length.out = 500)
logL_vals <- sapply(sigma_vals, log_likelihood, counts = counts, radii = radii)
likelihood_vals <- exp(logL_vals)  # Convert to likelihood

# Create data frame for plotting
df <- data.frame(sigma = sigma_vals, likelihood = likelihood_vals)

# Plot likelihood
ggplot(df, aes(x = sigma, y = likelihood)) +
  geom_line(color = "blue") +
  labs(title = "Likelihood vs. Sigma",
       x = expression(sigma),
       y = "Likelihood") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Posterior Generation

Now, we generate the posterior.

```{r}
library(pracma)  # For trapz() to numerically integrate

# Assume: sigma_vals, logL_vals, and likelihood_vals are already computed

# Convert sigma^2 to theta (variance parameter)
theta_vals <- sigma_vals^2

# Define Inverse Chi-Squared density (same as before)
dinvchisq <- function(theta, a, b) {
  const <- (b/2)^(a/2) / gamma(a/2)
  const * theta^(-(a/2 + 1)) * exp(-b / (2 * theta))
}

# Example: Use MLE estimates for prior
mle_a <- coef(mle_result_bull)[["a"]]
mle_b <- coef(mle_result_bull)[["b"]]

# Evaluate prior at theta values
prior_vals <- dinvchisq(theta_vals, mle_a, mle_b)

# Compute unnormalized posterior
unnormalized_posterior <- likelihood_vals * prior_vals

# Normalize posterior
posterior_vals <- unnormalized_posterior / trapz(theta_vals, unnormalized_posterior)

# Plot posterior
plot(theta_vals, posterior_vals, type = "l", lwd = 2, col = "purple",
     main = "Posterior Distribution of Theta",
     xlab = expression(theta), ylab = "Posterior Density")
```
